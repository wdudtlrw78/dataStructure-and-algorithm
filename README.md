# 기본개념 정리

## 자료구조 이론

<br>

## 알고리즘 이론

<br>

### <strong>시간 복잡도(time complexity)</strong>

- [중요한 개념이므로 블로그 참고](https://blog.naver.com/wdudtlrw/222263409365)

<br>

### <strong>공간 복잡도 (space complexity)</strong>

- 프로그램을 실행 및 완료하는데 필요한 저장공간의 양을 뜻함
- 통상 시간 복잡도, 공간 복잡도 둘 다 만족시키기 어렵다
  - 시간과 공간은 반비례적 경향이 있다.
  - 최근 대용량 시스템 보편화되면서, 시간 복잡도가 우선

총 필요 저장 공간

- 고정 공간(알고리즘과 무관한 공간): 코드 저장 공간, 단순 변수 및 상수
- 가변 공간(알고리즘 실행과 관련있는 공간): 실행 중 동적으로 필요한 공간
- S(P) = c + Sp(n)
  - c: 고정공간
  - Sp(n): 가변 공간
- Big-O 표기법 생각해볼 때, 고정 공간은 상수이므로 즉 가변 공간에 좌우된다.

<br>

### <strong>버블 정렬 (bubble sort)</strong>

- 두 인접한 데이터를 비교해서, 앞에 있는 데이터가 뒤에 있는 데이터보다 크면, 자리를 바꾸는 정렬 알고리즘

시간 복잡도

- O(n^2)
- 완전 정렬시 O(n)

<br>

### <strong>선택 정렬 (selection sort)</strong>

- 다음과 같은 순서를 반복하며 정렬하는 알고리즘

1. 주어진 데이터 중, 최소값을 찾음
2. 해당 최솟값을 데이터 맨 앞에 위치한 값과 교체함
3. 맨 앞의 위치를 뺀 나머지 데이터를 동일한 방법으로 반복함

- 코드가 간단하다.
- 작은 수 (보통 30 이하)에서는 효과적이다.

풀이

[9, 3, 2, 1] 배열 가정

- 처음 한 번 실행하면 [1, 3, 2, 9]
- 두 번째 실행하면 [1, 2, 3, 9]
- 세 번째 실행하면, 변화 없음

시간 복잡도

- O(n^2)
- 실제로 상세하게 계산하면, n \* (n - 1) / 2

<br>

### <strong>삽입 정렬 (insertion soort)</strong>

- 두 번째 인덱스부터 시작
- 해당 인덱스(key 값) 앞에 있는 데이터(B)부터 비교해서 key 값이 더 작으면, B값을 뒤 인덱스로 복사
- key 값이 더 큰 데이터를 만날때까지 반복, 그리고 큰 데이터를 만난 위치 바로 뒤에 key 값을 이동

풀이

[3, 7, 1, 5, 2] 배열 가정

- 두 번째부터 시작. 숫자 7을 선택
- [3, <b>7</b>, 1, 5, 2]
- 앞의 3과 비교 3보다 크기 때문에 그 자리에 둔다. 다음 숫자 1 선택
- [3, 7, <b>1</b>, 5, 2]
- 1은 앞의 3, 7보다 작기 때문에 3, 7 앞에 넣어준다. 다음 숫자 5 선택
- [1, 3, 7, <b>5</b>, 2]
- 5는 3보다는 크고 3, 7 보다 작기 때문에 그 사이에 넣어준다. 다음숫자 2 선택
- [1, 3, 5, 7, <b>2</b>]
- 마지막으로 1과 3, 5, 7 사이에 2 넣고. 다음 숫자가 없으므로 종료
- [1, 2, 3, 5, 7] 정렬 완료

시간 복잡도

- O(n^2)
- 완전 정렬시 O(n)

<br>
